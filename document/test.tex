\documentclass[10pt, article, natbib]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{mathtools}
\usepackage{tikz}

\pagestyle{fancy}
\fancyhf{Universidad Nacional de Costa Rica}
\rhead{\thepage}
\lhead{Proyecto \# 1}
\rfoot{EIF-212 Sistemas Operativos}
\lfoot{I-2023}

\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\makeatletter
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.3em}}
\makeatother
\begin{document}

\begin{titlepage}
	\includegraphics[width=0.2\textwidth]{./logo-UNA blanco.png}      
   	\begin{changemargin}{4.5cm}{0cm}
       	\textbf{\Huge Contando Bytes}

       	\vspace{0.2cm}
       	\LARGE Proyecto \# 1
            
       	\vspace{3cm}
		\Large
       	Jorge Durán Campos \\ 
       	Luis Antonio Montes de Oca Ruiz \\ 
       	Diego Quirós Artiñano \\ 

       	\vspace{3cm}
       
		EIF-212 Sistemas Operativos \\
       	Profesor Eddy Ramirez Jiménez \\
		       	
       	\vspace{3cm}
       	\today
	\end{changemargin}
\end{titlepage}

\onecolumn
% Índices
\pagenumbering{roman}
    % Contenido
    \renewcommand{\contentsname}{\large Índice \\ \hrulefill}
\tableofcontents
\setcounter{tocdepth}{2}
\newpage
%     Figuras
 \renewcommand{\listfigurename}{\large Índice de fíguras \\ \hrulefill}
 \listoffigures
 \newpage
     % Tablas
 \renewcommand{\listtablename}{\large Índice de tablas \\ \hrulefill}
 \listoftables
 \newpage

% Cuerpo
\pagenumbering{arabic}

\section{Resumen Ejecutivo}


\newpage
\twocolumn
\section{Introducción}
Este documento tiene como objetivo servir como documentación del primer proyecto del curso de sistemas operativos. Este consta de un resumen ejecutivo en el cual se resume el proyecto junto a su solución y resultados, un marco teórico donde se describen aspectos relacionados al proyecto, como el leguaje y las bibliotecas, una descripción de la solución implementada al problema planteado en el enunciado del proyecto, los resultados de las pruebas de la solución, las conclusiones donde se analizan los resultados y el proyecto en general, y por ultimo se presentan los aprendizajes obtenidos al realizar el proyecto. Así mismo, el proyecto se basa en realizar un programa lector de cualquier tipo de archivo, sea un video, un texto o demás, si este se sobrepasa de la cantidad de memoria disponible se realiza la lectura poco a poco, este archivo es leído de manera binaria usando hilos “productores” que van byte por byte, estos bytes se entregan a los hilos “consumidores”, y van a colocar cada uno de los 256 posibles valores de bytes en un arreglo de 256 espacios, en el que cada índice representa la cantidad de repeticiones de un byte en particular.

\section{Marco teórico}
El lenguaje utilizado en este proyecto es C, el cual se creó a principios de los años 1970 por Dennis M. Ritchie en Bell Laboratories. Este fue diseñado como un lenguaje minimalista para la creación de sistemas operativos para minicomputadoras, las cuales eran computadoras más baratas y menos potentes que una supercomputadora, pero más caras y potentes que una computadora personal. El principal motivo fue el deseo de migrar el kernel del sistema pronto a ser terminado, UNIX, a un lenguaje de alto nivel, teniendo las mismas funciones, pero con menos líneas de código. C se basó en CPL, o Combined Programming Language, por sus siglas en inglés, el cual a su vez sirvió de base para el lenguaje B. De este, Ritchie reescribió varias funciones de CPL para crear C y después reescribió UNIX en este nuevo lenguaje.\cite{encyclopdiabritannica_2022_c} \cite{munoz_after}\\

Desde 1977 hasta 1979 ocurrieron distintos cambios en el lenguaje, y durante este tiempo se publicó un libro que sirve como manual para el lenguaje, titulado "The C Programming Language", publicado en 1978 por Ritchie y Brian W. Kernighan. Cinco años después, se estandarizó C en el American National Standards Institute, y desde ese momento, al lenguaje se le refiere como ANSI Standard C. De C salieron varios lenguajes derivados, tales como Objective C y C++. Además, también surgió Java, el cual se creó como un lenguaje que simplifica C.\cite{mritchie_1993_the}\\

Continuando con los recursos utilizados en este proyecto, se utilizó la librería pthread. Esta es una librería de POSIX la cual es un estándar para el uso de hilos (threads), en C y C++, los cuales permiten un flujo de procesos de manera concurrente. El uso de estos hilos es mas efectivo en procesadores con múltiples núcleos, ya que se pueden asignar los procesos a distintos núcleos, haciendo la ejecución más rápido.\cite{ippolito_2020_linux}\\

Además, se escogió CLion como el IDE preferido para este proyecto. Este IDE es de la empresa JetBrains y fue lanzado al mercado en 2014\cite{avram_2014_jetbrains} con herramientas que ayudan a la creación de código, tales como refactoring, generación de código para sets/gets, terminación de código y arreglos rápidos del código escrito.\cite{jetbrains_intelligent}\\

Finalmente, ya que se mencionó tanto POSIX como UNIX se va a brindar información sobre estos. Portable Operating System Interface for UNIX, o POSIX, son estándares establecidos por la IEEE y publicados por la ANSI e ISO (International Organization for Standardization), estos estándares permiten el desarrollo de código universal, para que pueda correr en todos los sistemas operativos que implementen POSIX, tales como macOS o Ubuntu, la mayoría de los sistemas basados en UNIX cumplen con POSIX.\cite{universityinformationtechnologyservices_2021_about} UNIX es un sistema operativo que fue creado para brindar a programadores funciones simples pero potentes, y que permitiera el uso de múltiples usuarios y de multi tarea, este se compone de tres partes, el kernel, los archivos de configuración de sistema y los programas.\cite{idahostateuniversity_1997_what}

\section{Descripción de la solución}
El primer paso de la solución fue crear las distintas variables y definiciones para el programa. Primero los MUTEX para poder sincronizar los hilos productores y consumidores, manejando uno para la lectura de los bytes y otro para el consumo de estos.\cite{whiletruethendream_2020_mutex} \cite{cppdev_2010_c} \cite{manrow_2011_c} Seguidamente, se declaran condiciones de pthread para los productores y consumidores, estos funcionan como indicador de que terminaron su tarea correspondiente.\cite{theopengroup_1997_pthread_cond_wait} Existe un alias llamado BUFFERLEN el cual se va a utilizar como el tamaño del buffer de lectura para productores, este buffer es un array que se crea con un espacio de 1000 bytes y asimismo se utiliza otro array para la solución con 256 espacios, que representa cada byte posible. También, se crean dos indicadores de posición para los productores y consumidores, que indica la última posición de lectura. Se declara la variable que indica la cantidad deseada de hilos productores y consumidores, la dirección del archivo a probar, el tamaño de este archivo y la posición final de los lectores. Por último, se crea un flag que indica cuando se llega al final de la lectura del archivo.\\

Se realiza un merge sort para poder ordenar los resultados de mayor a menor repeticiones por cada byte, este merge sort se maneja por un método auxiliar llamado merge y otro llamado mergesort, el auxiliar se encarga de toda la lógica de ordenamiento en el auxiliar y el mergesort se encarga de unir la respuesta dentro de un array final.\\

Se crea el método reading file el cual es el que los hilos productores se encargan de ejecutar. Este va a abrir el archivo indicado en la dirección indicada en la ejecución del programa.\cite{chanilastnam_2015_c} \cite{cppreferencecom_2021_fread} \cite{kerrisk_2010_fseek3} Por mientras que no se haya llegado al final del archivo, se realiza un bloqueo del mutex para el buffer de lectura de los productores, para que ningún otro hilo productor toque este buffer, si el hilo que bloqueó este mutex se encuentra al final del documento, entonces se va a desbloquear para asegurarse que ningún otro hilo se quede pegado dentro del condition, si no, se continua con la lectura del byte del archivo, si la posición siguiente del productor es igual que la posición del consumidor entonces se llama un wait condition, utilizando la condición de consumo y el mutex del buffer, esto para detener a los productores hasta que se consuma, si esto no ocurre se sigue normal, se aumenta el indicador de posición de productores, si se llega al fin del documento se marca el flag en 0, desbloquea el mutex del buffer y se indica que se terminó con la señal de condición de read condition, se cierra la lectura del archivo y por último se destruyen los hilos productores.\cite{kerrisk_2010_pthread_exit3} \\

Luego, se crea el método adding to array, el cual es el proceso de los consumidores. Este por mientras que la variable filelen sea 1 se ejecuta toda su lógica, si no se eliminan los threads consumidores. Si esta variable si es true entonces se empieza el trabajo de los consumidores, primero bloqueamos el mutex del array de la solución, si filelen es 0 entonces se desbloquea el array y se eliminan los consumidores, si no se continua. Además, existe un while donde si la posición siguiente de los consumidores es igual a la posición de los productores y el flag de final de archivo está en true entonces los consumidores esperan a que los productores generen mas bytes para leer e estos indiquen cuando lo hagan, y también hay un if que si el indicador filelen es falso entonces de desbloquea el mutex del array de solución y se eliminan los threads consumidores. Finalmente, si no se entra en cualquiera de estos ciclos entonces como cada posición del array indica el byte correspondiente, entonces se aumenta en 1 para indicar la cantidad de repeticiones por cada byte, esta posición se modifica leyendo cada posición del buffer, tomando como índice el restante de la división de la posición de los consumidores entre el alias BUFFERLEN, se aumenta la posición de los consumidores y se disminuye filelen y por ultimo se desbloquea el mutex de la solución, se envía la señal que se termino de consumir y se eliminan los consumidores.\\

Para terminar, dentro del main primero creamos un array auxiliar para la solución, donde se ordenan los bytes de mayor a menor repetición del array original de solución. Luego se realizan verificaciones para revisar si se da el número de hilos productores o consumidores deseados o la dirección del archivo a leer. Luego se abre el documento para probar si se logra abrir correctamente, si no se termina la ejecución del programa, y luego se recorre todo el archivo para encontrar su tamaño, se devuelve el puntero que controla lectura y se cierra. Luego se hace la creación de productores con su asignación de la tarea del método reading file, si falla se detiene el programa, al igual con los consumidores con su método adding to array, si falla también se detiene. Por ultimo se le hace join al hilo principal del programa a los productores y consumidores, si falla se detiene el programa.\cite{kerrisk_2010_pthread_join3} Seguidamente, se ejecuta el mergesort para ordenar el solution array dentro del solution aux declarado al principio del main, y luego imprimiendo el resultado de las repeticiones, usando ambos arrays de solución, uno para indicar el byte y otro para indicar sus repeticiones, y por ultimo se destruyen los mutex y las condiciones.\\

\section{Resultados de pruebas}

\section{Conclusiones}

\section{Aprendizajes}

\newpage
\onecolumn
\bibliographystyle{ieeetr} 
\bibliography{ref.bib}

\end{document}
